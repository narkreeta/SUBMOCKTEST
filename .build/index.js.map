{
  "version": 3,
  "sources": ["../index.ts"],
  "sourcesContent": ["import { ANTLRInputStream, CommonTokenStream } from 'antlr4ts';\nimport {QSharpLexer} from \"./CSHARP/QSharpLexer.ts\"\nimport {QSharpParser} from \"./CSHARP/QSharpParser.ts\"\nimport { QSharpParserVisitor } from './CSHARP/QSharpParserVisitor.ts'\nimport { AbstractParseTreeVisitor } from 'antlr4ts/tree/AbstractParseTreeVisitor'\n\nconst input = `using System;\n\nnamespace Conditional\n{\n\tclass Ternary\n\t{\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tint number = 2;\n\t\t\tbool isEven;\n\n\t\t\tisEven = (number % 2 == 0) ? true : false ;  \n\t\t\tConsole.WriteLine(isEven);\n\t\t}\n\t}\n}`\n\n// Create the lexer and parser\nlet inputStream = new ANTLRInputStream(input);\nlet lexer = new QSharpLexer(inputStream);\nlet tokenStream = new CommonTokenStream(lexer);\nlet parser = new QSharpParser(tokenStream);\n\nlet tree = parser.document()\n\n// Extend the AbstractParseTreeVisitor to get default visitor behaviour\nclass CountFunctionsVisitor extends AbstractParseTreeVisitor implements QSharpParserVisitor {\n\n  defaultResult() {\n    return 0\n  }\n\n  visitFunctionDeclaration(context: FunctionDeclarationContext): number {\n    if(context.children){\n      console.log(context.children.length)\n    }\n    return 0;\n  }\n}\n\n// Create the visitor\nconst countFunctionsVisitor = new CountFunctionsVisitor()\n// Use the visitor entry point\ncountFunctionsVisitor.visitFunctionDeclaration(tree)"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA,sBAAoD;AACpD,yBAA0B;AAC1B,0BAA2B;AAE3B,sCAAyC;AAEzC,MAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBd,IAAI,cAAc,IAAI,iCAAiB;AACvC,IAAI,QAAQ,IAAI,+BAAY;AAC5B,IAAI,cAAc,IAAI,kCAAkB;AACxC,IAAI,SAAS,IAAI,iCAAa;AAE9B,IAAI,OAAO,OAAO;AAGlB,oCAAoC,yDAAwD;AAAA,EAE1F,gBAAgB;AACd,WAAO;AAAA;AAAA,EAGT,yBAAyB,SAA6C;AACpE,QAAG,QAAQ,UAAS;AAClB,cAAQ,IAAI,QAAQ,SAAS;AAAA;AAE/B,WAAO;AAAA;AAAA;AAKX,MAAM,wBAAwB,IAAI;AAElC,sBAAsB,yBAAyB;",
  "names": []
}
